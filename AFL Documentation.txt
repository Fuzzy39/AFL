This document is basically documentation for a 'programming language' I'm making called AFL.
[?] means that the entry has not yet be written (most of them, jeez)
Eventually I'll feed all of this into the help utility code.

[-1] Index 
-----------------------
A list of all help topics is below.

-- See also: ------------
[0] Welcome To AFL!
[1] General Info 
[2] AFL Basics 
[3] Data Types
[4] Variables 
[5] Operators
[6] Control Statements
[7] Functions
[8] Arrays
[9] Components
[10] Escape Sequences
[11] Command Line Arguments
[?] Code Examples
[Reference]
[?] Function Index
[?] Core Functions
[?] Math Component
[?] Util Component



[0] Welcome To AFL!
-----------------------
Arguably Functional Language is a relatively simple programming language made to learn how 
programming languages work. It has a few features, including functions, (limited) variable 
scoping, and arrays. If you would like to know more, you can recall a specific entry by 
typing 'help(EntryID)'. An index of helpful starting points is listed below with their 
IDs. If you want an index of all articles, type 'help(neg(1))'.

-- See also: ---------
[1] General Info 
[2] AFL Basics 
[3] Data Types
[4] Variables 
[6] Control Statements
[7] Functions
[8] Arrays
[9] Components
[11] Command Line Arguments
[?] Code Examples
[?] Default AFL Components
[?] Function Index
-----------------------

[1] General Info
-----------------------
Arguably Functional Language is an (arguably) interpreted programming language written in
Java. AFL is a dynamically and strongly typed language. AFL notably supports variables 
with limited scoping, functions, arrays, and separating code into files, called components.
AFL was built as a learning project, and as such is probably not efficient or properly 
useful, though it should work as expected in most cases. 

There are probably some situations in which AFL doesn't work as expected. If you find a 
problem, I'd love to hear about it! Email me at jmcraft126@gmail.com, though I wouldn't hold
your breath for it to get fixed.

If you want to look at AFL's source code, you're welcome to, though fair warning,
it's a little grisly. Just head over to https://github.com/qwerty4967/AFL


-- See also: ----------
[2] AFL Basics 
[3] Data Types
[4] Variables 
[6] Control Statements
[7] Functions
[8] Arrays
[9] Components
-----------------------


[2] AFL Basics
-----------------------
This help entry contains a broad overview for a number of basic topics required to 
understand most AFL code. Hopefully most of it is relatively straightforward.

Data Types:

AFL has various types of data that you can manipulate, and has specific ways of writing them
as constants. The various types are num, string, char, bool, array, and type. For more 
information on data types, see their corresponding entry.

Printing:

AFL has no print statement. If you want to print something to the console, just type it out!
Here are some examples:
-------
"Hello, World!"
1+1
round(1.1)
------

Multiple Statements: 

Statements in an AFL program are separated by semicolons. This is always the case, no matter
where the semicolon is in AFL code. Because statements are separated by semicolons, and not 
ended by them, AFL expects the last statement in a piece of code to not be ended by a 
semicolon. If you want to use a semicolon in a way that does not denote a new statement,
you can escape them with a backslash. See the entry on escape sequences to learn more about
escaping other characters.

Variables & Arrays:

AFL supports variables, which are used to store values. Assigning a variable is fairly 
simple:
--------
name = value
-------- 
Using a variable is also fairly simple. Just write out it's name. Try out this example:
--------
x = 2+1;
"x squared:";
x*x
--------
If you want more specific information on variables and variable scoping, check out the 
entry on variables below.

AFL also supports arrays, which are special variables that can store multiple values. Check
out the entry on arrays for more information.

Comments:

AFL provides ways to insert comments that are not executed into your code, usually to
explain the function of your code. AFL uses # to denote a comment for a single line, though
note that semicolons in comments have to be escaped.

Operators and Functions:

AFL provides various ways to modify values. These include operators such as +, *, and ==,
and functions, such as round(num) and random(). Functions in particular do not have to
output any value, however. You can also create your own functions. To learn how to make and
call functions, see the corresponding entry on functions below.

Control Statements:

AFL also supports what it calls control statements, which are functions that modify the flow
of code execution. These include the commonplace if(bool) and while(bool). To see syntax for 
them and a list of all control statements, see the corresponding entry below.

-- See also: ----------
[3] Data Types
[10] Escape Sequences
[4] Variables
[8] Arrays
[5] Operators
[?] Math Component
[7] Functions
[5] Control Statements
-----------------------



[3] Data Types
-----------------------
AFL has various types of data that you can manipulate, and has various ways as writing them
as constants. All types of data can be put into variables. This Entry contains a list of
data types, how to enter them as constants, and some assorted notes on them.

num:
The num data type is for storing numbers. All num's are double precision floating points,
completely stolen from java. They may be entered as expected for the most part, but AFL
refuses to recognize scientific notation, values like NaN and Infinity, and negative numbers
as numbers, when written as constants, though these values can still be obtained with 
expressions. Note that there is a utility function for producing a negative number, 
neg(num).

string:
The string data type represents text, and is written as a constant using quotation marks,
like so:
"Hello, World!"
Strings can be easily combined (or other types can be appended on to strings) by using the
+ operator. They can also be converted to and from arrays of char type data using the
toCharArray(string) and fromCharArray(array) functions. Certain characters cannot be easily 
inputed into strings, and for these characters, escape sequences are available. See the
entry below for more information.

char:
The char data type represents a single character, such as 'a', '!' or '1'. They are
represented by single quotes surrounding the character in question, like shown above.
Certain characters cannot be easily inputed, and for these characters escape sequences 
are available. See the entry below for more information.

bool:
The bool data type represents true or false, and are the results of comparisons e.g. x>10. 
They are represented by the words true and false, fittingly enough. 

array:
The array data type cannot be directly represented, though they are stored in variables.
They are manipulated through array functions. arrays represent multiple values in one,
indexable by a num. For more information on arrays and how to use them, see the 
corresponding Entry.

type:
The type data type represents the data types, num, string, char, bool, array and type, and
are written as such. types are used most often when determining the type of a potentially
unknown variable, typically like so:
-----
if(typeOf(x)==num);
    # do something if x is a num
end();
else();
    # do something if x is not a num
end()
-----


-- See also: ----------
[4] Variables
[?] Math Component
[5] Operators
[?] Util Component
[10] Escape Sequences
[8] Arrays
-----------------------


[4] Variables 
-----------------------
AFL supports variables, which are used to store values. Assigning a variable is fairly 
simple:
-----
name = value or expression
-----
Valid names are of any length, and only consist of upper and lower case letters. The
recommended way to capitalize variables is camelCase or UpperCamelCase.
some examples of variable assigning:
-----
x=12;
output = "The answer is: "+27.5+'!'
someNumber=pi*sqrt(2)
-----
Variables can be recalled by using their name in place of a constant value. For full 
clarity, here is an example:
-----
x=27;
x=x+1;
# Expected value is 28;
x
-----

Variable Scoping:

Variables are scoped by functions. This means that a variable first declared outside a 
function is available to all functions, but a variable declared inside a function is only
accessible within that function. If that variable is used in another function, it refers
to an unrelated value. A variable cannot be first declared in a function, then used outside
of one.
Here is an example:
-----
# this code will produce an error, as x is undefined in function b.
function("a" 0);
    x=201;
end();
function("b" 0);
    x;
end();
a();
b()
-----

-- See also: ----------
[5] Operators
[?] Math Component
[7] Functions
[8] Arrays



[5] Operators
-----------------------
AFL uses operators to describe basic operations, such as the + operator for addition. All 
Operators have two operands, to each side of them. AFL utilizes the order of operations,
with certain operations being executed before others. This entry describes Each 'priority 
category' of operators from highest to lowest priority, with notes for certain operators 
when required.

Organize Category Operators:
 ( and ) are Organize operators, but they do not correspond to any operations, and
prioritize the expression inside of them, ensuring all of it is done as a unit.
Parenthesees are also used to describe function calls, but are used in a slightly different
capacity. Here is an example of parentheses used as organize operators:
-----
4*2+3; # outputs 11
4*(2+3) # outputs 20
-----

Multiply Category Operators:
The multiply category operators are *, /, and %, and perform multiplication, division, and
modulus (division remainders) respectively on num type operands.

Add Category Operators:
The add category operators are + and -, and perform addition and subtraction respectively on
num type operands.
+ can also utilize operands of other types, and if any operand of + is not a num,
it will concatenate both types together and output a string.

Compare Category Operators:
The compare category operators are ==, !=, >=, <=, >, and <. These operators
return a boolean value.
== returns true if its two operands have the same values. Arrays are only equal to 
themselves. Arrays with the same size and list of values will not be equal.
!= returns true if its two operands do not have the same values.
>= only operates on num type operands, and returns true if the first operand is greater than
or equal to the second.
<= only operates on num type operands, and returns true if the first operand is less than or
equal to the second. 
> only operates on num type operands, and returns true if the first operand is greater than
the second.
< only operates on num type operands, and returns true if the first operand is less than the
 second.

Logic Category Operators:
The logic category operators are || and &, and perform boolean or and and operations.
or returns true if either operand is true, and and returns true only if both operand are 
true.	

Assignnment Operator:
= is the Assignment operator, which is used to assign variables. Refer to the entry on 
Variables for information on how it works.                                                                                                                                                                                                                          z.

-- See also: ----------
[3] Data Types
[4] Variables
[7] Functions




[6] Control Statements
-----------------------
AFL supports a number of what it calls control statements, which are functions that control 
the normal flow of code. Certain control statements are used with code blocks, which start
with the control statement, and end with the use of the end() function. It is required that
all code blocks are ended. Code blocks can also be nested. It is customary to indent all 
code within a code block. This entry lists all control statements, and how they are used.
control statements cannot be part of an expression, though their parameters can be made
of expressions.

Code Block Creating Control Statements:
if(bool):
  The if control statement executes the code within its block if its parameter is true.
  If it is false, the code within its block is ignored and skipped.
else():
  The else control statement can only be used after the end of an if statement's code block.
  The code within its block only runs if the code in the if statement's block did not. Note
  that any check in an if statement will be run again in the else statement.
while(bool):
  The while control statement executes its block of code if the condition is true, similarly
  to the if statement, but after it reaches the end of its block, it checks the condition
  again, and will continuing executing the code in its block until it is false.

Other Control Statements:
return() and return(value):
	The return function is tied to functions. when return is run, the function currently
	running is stopped, and if any value is returned, it is passed to the code that called
	the function.
	For example, imagine you have a function to double a number:
	-----
	function("double" 1);
		return(2*arrayGet(params 0));
	end()
	-----
	the return function here will allow us to get the value the function generates.
	double(10) # will print "20.0"
	
break():
	The break function only works inside of while loops, and when called, immediately ends
	running code inside of the loop.
continue():
	The continue function only works inside of loops, and when called, returns to the start
	of the loop.

See also:
--------------------
[3] Data Types
[7] Functions
[?] Math Component
--------------------


[7] Functions
--------------------
Functions are ways to easily group a bunch of code together to run at once, on command.
This is incredibly powerful because it makes code shorter and easier to read.
Function syntax involves two parts: creating functions and calling (running) them.

Calling functions:
if you're reading this, you've already called a function with AFL. when you wrote 'help(7)',
you called the function help. yep, the help system is a function, and it's actually written
in AFL code.
The syntax for calling a function is as follows:
functionName( parameters )
every function has a certain number of parameters it expects, and needs to be given that
amount. parameters are separated by spaces (if required). Here are some examples:
the function 'clear' expects no parameters, and can be called as 'clear()'
the function 'pow' expects two parameters and could be called like 'pow(3 3)'
It should be noted that function calls can both contain expressions in their parameters and
be part of expressions.

Creating functions:
Functions work similarly to control statements, in that the function definition
creates a block of code ended by the end() function. 
The definition of a function is itself a function (kinda), and looks like this:
function(functionName params);
functionName is of string type, and will the name of the function when you call it. It can
be any combination of letters, and it cannot include any numbers, spaces, or symbols. 
params is of num type, and is the amount of parameters your function expects. Note that
expressions cannot be used in the parameters for the function function. Only constants.
here is an example of a function.

Also note that function definitions ignore other code blocks, and whether code in a 
specific block is run does not effect whether the function is defined. It is customary to 
define functions outside of any other code blocks to make code more understandable. 

------
function("example" 0);
	"hello there!";
	# isn't this a cool function? no? whatever;
	"more words!";
end()
-----
this function can then be called with 'example()'.

Each function comes with an array called 'params', which holds all of the parameters
that the function has been called with. It is accessed with array related functions as
normal. See the entry on arrays for information about handling them.

Functions can also return values. this is accomplished through the return function.
the return function can have zero or one parameters. If it has 0, it ends the function's
execution and returns nothing. if it has 1, it ends the functions's execution and produces
that value.

Here is an example function that increments by 1 the number that is put into it.
-----
function("increment"1);

	# get the first parameter;
	toReturn = arrayGet(params 0);
	
	# increment and return it;
	toReturn = toReturn + 1;
	return(toReturn);
	
end();

# some test cases;
increment(1); # prints 2;
4*increment(4); # prints 20;
increment("zebra fish"); # prints 'zebra fish1';
increment(true); # produces an error;
-----
 
The last example produces an error, because the increment function didn't handle receiving 
parameters of unexpected types. For some cases this might be fine, but if you want to 
create a more robust system, AFL provides a function that simplifies the ordeal, called
checkParam. Check out the reference for the util component for more information.

See Also: --------------------
[3] Data Types
[6] Control Statements
[?] Util Component
[?] Base Component


[8] Arrays
--------------------
Arrays are special types that contain multiple values in an ordered list. Arrays are
manipulated and created through special functions, which are detailed below.

newArray()
newArray returns an empty array. Arrays must be created with this method before they can be 
utilized.

arrayAdd(array value)
arrayAdd adds an item to the end of a specified array. the value can be anything, but an
array cannot contain itself.

arrayGet(array index)
arrayGet returns the item at the specified index of the array, provided that it exists.
Arrays are indexed from 0.

arraySize(array)
returns the number of items in the array.

arraySet(array index value)
arraySet sets the index of a particular array to the specified value, provided the array
already has an value at the specifed index.

arrayRemove(array)
removes the last item from the array.

arrayRemove(array index)
removes the item at the specified index from the array.

See Also: ------------
[7] Functions
[3] Data Types
-------------------------

[9] Components
-----------------------
AFL provides methods to introduce utility and other functions and variables into the 
namespace at startup, in order to provide a more convenient coding experience. These are
called components, and are essentially files of AFL code. by default, AFL comes with 3
'core components', which are explicitly checked for when AFL starts. These components are
called Math, Util, and Help. 
It should be noted that the Help component is not initialized if AFL is to be running files.
For more information on this, check out the entry on command line arguments.
You can create a component by placing a file of AFL code into AFL's 'lib' folder. Placing
components in any subfolder of lib will not be executed.

See Also: -------------
[11] Command Line arguments
[?] Math Component
[?] Util Component
-----------------------


[10] Escape Sequences
-----------------------
Some characters cannot be easily input into strings, so AFL provides escape sequences to
more easily produce them.
AFL provides 4 escape sequences, as follows:
\; produces a semicolon without ending a code statement.
\n produces a line break
\' produces a single quote, which is ignored for the purposes of defining characters.
\" produces a double quote, which is ignored for the purposes of defining strings.

Note that \; can be used outside of strings and characters, though there is no use for this
behavior.

See Also: ---------------
[3] Data Types
[11] Command Line arguments
-------------------------

[11] Command Line Arguments
------------------------------
AFL, when launched via the command line, provides a couple command line arguments.
the typical method to run AFL is as follows
-----
java -jar path/to/AFL.jar
-----
but up to 2 command line arguments can be added.

first: debug, followed by an integer between 0 and 4. having debug at a nonzero value will
display information about code being parsed, with higher values describing more details.
no additional output is produced when code is executed, only when it is parsed.

second: run, followed by any number of file paths. this will have afl parse and execute each
file as AFL code, in sequence.

debug must always come before run, if both are used.

See Also:-----------
--------------------
 